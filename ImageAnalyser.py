# This file is used for all the analysis of the image
import matplotlib.pyplot as plt
import numpy as np
from numpy import trapz
from scipy.signal import argrelextrema
import ImageManipulation
import cv2
from tkinter import *
import operator
import GraphAnalysis

PIXEL_HEIGHT = 8  # radius i.e. middle to top DEFAULT = 8
CUT_OFF = 2000  # This value is used to find the end of dna spots, if the brightness is under 2000 it assumes it is
# the end of a dna spot
AVG_CENTROID_INTENSITY = 0
root = Tk()


# Get intensity is passed the image and the lines. It will run along the pixels in each line and get the intensity
# of each pixel adds all the intensities to a list
def get_intensity(image, centroids):
    list_of_dna = get_drop_off(centroids, image)
    dna_height_data = extend_DNA_spots(centroids, image, list_of_dna)
    spacings = max_spacing_lines(dna_height_data)
    centroids = extend_points(centroids, image, spacings)

    ImageManipulation.draw_lanes(centroids, image.copy())
    cv2.imshow('testimage', ImageManipulation.draw_lanes(centroids, image.copy()))
    cv2.waitKey(0)
    single_row_intensities = []
    all_intensities = []
    _, width, _ = image.shape

    for point in centroids:
        lengthofcent = len(point)
        start = point[0][0]
        end = point[lengthofcent - 1][0]
        y = point[0][1]

        counter = 0
        for i in range(start, end):
            addintensity = 0
            points = spacings[counter]
            #point = points[0]
            for yedit in range(points[0], points[1]):
                # The intensity of the image is calculated by taking the values for red blue and green and summing the
                # values.
                r, b, g = image[y, i]
                r = int(r)
                b = int(b)
                g = int(g)
                # Convert to int so it doesn't get an error
                intensity = int(r + b + g)
                addintensity = addintensity + intensity
            single_row_intensities.append(addintensity)
        counter += 1
        all_intensities.append(single_row_intensities[:])
        single_row_intensities.clear()
    # some_testing(all_intensities, centroids, image)
    tosend = decrease_values(all_intensities)
    some_testing(tosend, centroids, image, spacings, list_of_dna)


# This is called from get_intensity and takes the data generated by it and will make simple graphs from the data
# the Y axis is the intensity and the X axis is the pixel number (basically depth)
def simple_graphing(data, centroidedges):
    for i in range(len(data)):

        data_point = data[i]
        title = ("Lane " + str(i))
        count = []
        for x in range(len(data_point)):
            count.append(x)

        fig, ax = plt.subplots()
        ax.plot(count, data_point)
        fig.suptitle(title)

        plt.axvline(x=0)
        plt.axvline(x=centroidedges[i][0])
        plt.axvline(x=centroidedges[i][1])
        plt.axvline(x=len(data[i]) - 1)
        plt.show()
        # Uncomment this so show graphs


# Sorts centroids
def sort_cent(cent):
    sorted_centroids = sorted(cent, key=lambda x: x[0])
    return sorted_centroids


# This function makes sure that the whole light spot (left and right) will get analysed
# it will extend the length of the line until there is no more light and therefore not the dna
def extend_points(centroids, image, spacing):
    to_add = []
    to_be_added_to = []
    _, width, _ = image.shape
    counter = 0
    # Loop through the lines, extend the first point on each line until it is no longer on the dna, do the same
    # with the last point on the line
    for cent in centroids:

        cent = sort_cent(cent)
        cent_len = len(cent)
        for i in range(cent_len):
            top = spacing[counter][0]
            bottom = spacing[counter][1]
            x = cent[i][0]
            y = cent[i][1]
            # If first point go here
            if i == 0:
                end_hit = False
                changer = 1
                while not end_hit:
                    totalint = 0
                    for changey in range(top, bottom):
                        r, b, g = image[y + changey, x - changer]
                        intent = pixel_intent(r, g, b)
                        totalint = totalint + intent
                    if totalint < 1400 or x - changer == 0:
                        end_hit = True
                    else:
                        changer = changer + 1
                edited_point = (x - changer, cent[0][1])
                # If it is the final point go here
            elif i == cent_len - 1:
                end_hit = False
                changer = 1
                while not end_hit:
                    totalint = 0
                    for changey in range(top, bottom):
                        r, b, g = image[y + changey, x + changer]
                        intent = pixel_intent(r, g, b)
                        totalint = totalint + intent
                    if totalint < 1400 or cent[i][0] + changer == width - 1:
                        end_hit = True
                    else:
                        changer = changer + 1
                edited_point = (cent[i][0] + changer, cent[i][1])
                # If it is neither it means the point is in the middle of the line, therefore it doesnt need changing
                # so just copy it over
            else:
                edited_point = cent[i]
            to_add.append(edited_point)
        counter += 1
        to_be_added_to.append(to_add[:])
        to_add.clear()
    return to_be_added_to


# Given red, blue and green values for a pixel it converts it to integers and sums them, it doesnt do
# a lot of computation but it gets called a lot so it saves space
def pixel_intent(r, g, b):
    r = int(r)
    b = int(b)
    g = int(g)
    # Convert to int so it doesn't get an error
    intensity = int(r + b + g)
    return intensity


#Edit this one
# This method is used to fund the edges of the dna spots. It returns the end of the fist spot and
# the start of the final dna spot will be changed to make it better soon
# It will only edit the first and the last points.

# It uses the current pixel as the cutoff as the pixles in centroids have been shifted to the start and end of
# the dna spots. So in theory the the darkest point past these points should be the other side of the dna spot
# which is what it is looking for
def find_edges(centroids, image, spacings, intents):
    to_add = []
    _, width, _ = image.shape
    edgy_centroids = []
    counter = 0
    for current_lane in centroids:
        number_of_points = len(current_lane)
        line = intents[counter]
        for current_point_index in range(number_of_points):
            x = current_lane[current_point_index][0]
            y = current_lane[current_point_index][1]
            if current_point_index == 0:
                r, b, g, = image[y, x]
                current_pixel_intensity = pixel_intent(r, b, g,)
                cutoff = current_pixel_intensity
                end_hit = False
                changer = 1
                while not end_hit:
                    r, b, g = image[y, x + changer]
                    intent = pixel_intent(r, g, b)
                    if intent < (cutoff + cutoff * 0.15) or intent > (cutoff - cutoff * 0.15):
                        end_hit = True
                    else:
                        changer += 1
                edited_point = (x + changer, current_lane[0][1])
                to_add.append(current_lane[current_point_index])
                to_add.append(edited_point)

            elif current_point_index == number_of_points - 1:
                r, b, g, = image[y, x]
                current_pixel_intensity = pixel_intent(r, b, g,)
                cutoff = current_pixel_intensity
                end_hit = False
                changer = 1
                while not end_hit:
                    r, b, g = image[y, x - changer]
                    intent = pixel_intent(r, g, b)
                    if intent < cutoff or intent > (cutoff - cutoff * 0.15):
                        end_hit = True
                    else:
                        changer += 1
                edited_point = (x - changer, current_lane[0][1])
                to_add.append(edited_point)
                to_add.append(current_lane[current_point_index])
        counter += 1
        edgy_centroids.append(to_add[:])
        to_add.clear()
    return edgy_centroids


# ignore this
# for changey in range(top, bottom):
#    r, b, g = image[y + changey, x - changer]
#    intent = pixel_intent(r, g, b)
#    totalint = totalint + intent
# if totalint < cutoff or cent[i][0] - changer <= 0:
#    end_hit = True
# else:
#    changer = changer + 1


# Just use to decrease values that are in background to 0 so middle values doesn't get free area
# for now it will just -1500 (generally what I've seen as the cut off between on cells and not)
# hopefully this will be changed later
def decrease_values(data):
    newvals = []
    toreturn = []
    #backgroung = GraphAnalysis.get_background_signal(data)
    for intensityrow in data:
        backgroung = GraphAnalysis.get_background_signal(intensityrow)
        for x in intensityrow:
            if x - backgroung <= 0:
                newvals.append(0)
            else:
                newvals.append(x - backgroung)
        toreturn.append(newvals[:])
        newvals.clear()
    return toreturn


# split_into_sections takes the data will call go_along_data in GraphAnalysis and will find the first middle and last
# peak in the data. It passes back the position of the cuts and the cuts as they are both need at some point
# Will be cleaned up more at a later date
def split_into_sections(data, sections):
    toadd = []
    final = []
    for i in range(len(data)):
        for x in range(2):
            use = data[i]
            if x == 0:
                op = operator.add
                length = 0
            else:
                op = operator.sub
                length = len(use) - 1
            point = GraphAnalysis.go_along_data(use, length, op)
            toadd.append(point)
        final.append(toadd[:])
        toadd.clear()
    print()
    returnsections = []
    passback = []
    for i in range(len(final)):
        firstpeak = data[i][0:final[i][0]]
        middlepeak = data[i][final[i][0]:final[i][1]]
        lastpeak = data[i][final[i][1]: len(data[i])]
        returnsections.append(firstpeak)
        returnsections.append(middlepeak)
        returnsections.append(lastpeak)
        passback.append(returnsections[:])
        returnsections.clear()
    return final, passback


# This is just to test some stuff to do with editing the data remove at the end
def some_testing(data, centroids, image, spacing, intents):
    a = np.array(data[0])
    print("1")
    maxInd = argrelextrema(a, np.greater)
    print(maxInd)
    print("2")
    r = a[maxInd]
    centroids_with_edges = find_edges(centroids, image, spacing, intents)
    splits, datas = split_into_sections(data, centroids_with_edges)
    simple_graphing(data, splits)
    get_areas(datas)
    print("3")
    print(r)


def get_areas(datas):
    areas = []
    for data in datas:
        toadd = []
        for i in data:
            y = np.array(i)
            area = trapz(y, dx=1)
            toadd.append(area)
        areas.append(toadd[:])
        toadd.clear()

    normalise_values(areas)


def normalise_values(data):
    import FileWriter
    normalised_values = []
    for values in data:
        toadd = []
        total = sum(values)
        toadd.append(round((values[0] / total)*100, 2))
        toadd.append(round((values[1] / total)*100, 2))
        toadd.append(round((values[2] / total)*100, 2))
        normalised_values.append(toadd[:])
        toadd.clear()

    FileWriter.write_to_file(normalised_values)


# This method will work out the intensity of the center of a dna spot. This is used when the edges of the
# dna needs to be calculated it makes it easier to tell based of intensity when a pixed that is not on the dna
# spot has been hit.
def get_drop_off(centroids, image):
    avg_int = 0
    count = 0
    total_int = 0
    final_list = []
    list_of_intent = []
    # Loop through lines and then points on each line
    for cent in centroids:
        for point in cent:
            r, b, g = image[point[1], point[0]]
            intent = pixel_intent(r, g, b)
            total_int += intent
            count += 1
            list_of_intent.append(intent)

        avg_int += total_int
        total_int = 0
        final_list.append(list_of_intent[:])
        list_of_intent.clear()
    avg_int = avg_int/count
    global AVG_CENTROID_INTENSITY
    AVG_CENTROID_INTENSITY = avg_int
    return final_list


# (top, bottom)
# This method find the top and bottom point for one line of dna, used to make sure the whole profile of the dna
# is read and not just one line.
def extend_DNA_spots(centroids, image, listint):
    changer = 0
    dna_edges = []
    line_points_to_add = []
    arraycount = 0
    intcount = 0
    linecount = 0
    for cent in centroids:
        currline = listint[linecount]
        for point in cent:
            is_hit = False
            bottom = 0
            currintent = currline[intcount]
            arraycount += 1
            # Loop going down in the image (+1) and if the brightness goes down 15% from the middle
            # intensity store the position
            while not is_hit:
                changer += 1
                r, b, g = image[point[1] + changer, point[0]]
                intent = pixel_intent(r, g, b)
                if intent < (currintent - currintent * 0.15):
                    bottom = changer
                    is_hit = True
                    changer = 0
            is_hit = False

            # Do the same again but going up in the image
            while not is_hit:
                changer += 1
                r, b, g = image[point[1] - changer, point[0]]
                intent = pixel_intent(r, g, b)
                if intent < (currintent - currintent * 0.15):
                    top = -changer
                    spacing = (top, bottom)
                    is_hit = True
                    changer = 0

            # Add the top and bottom
            line_points_to_add.append(spacing[:])
            intcount += 1
        dna_edges.append(line_points_to_add[:])
        line_points_to_add.clear()
        intcount = 0
        linecount += 1
    return dna_edges


# This method takes the output of extend_DNA_spots and will work out the widest gap (lowest bottom and highest top) in
# order to make sure non of the dna spot it missed
def max_spacing_lines(spacings):
    new_spacings = []
    for one_line in spacings:
        counter = 0
        max_top = 0
        max_bottom = 0
        for point in one_line:
            top = point[0]
            bottom = point[1]
            if top < max_top:
                max_top = top
            if bottom > max_bottom:
                max_bottom = bottom
            counter += 1
        new_spacings.append((top, bottom))
    return new_spacings


