import operator
import GraphAnalysis
import FileWriter
import matplotlib
matplotlib.use("TKAgg")
import matplotlib.pyplot as plt
import numpy as np
from numpy import trapz
import os


def analyse(data, key):
    filepath = FileWriter.get_file()
    splits, datas = split_into_sections(data)
    if key == ord("g"):
        simple_graphing(data, splits, filepath)

    caller_function(datas, filepath)


    # split_into_sections takes the data and will call go_along_data in GraphAnalysis and will find the first middle
    # and last peak in the data.
    # It passes back the position of the cuts and the cuts as they are both need at some point
    # Will be cleaned up more at a later date

def split_into_sections(data):
    toadd = []
    final_sections = []
    for data_point in range(len(data)):
        for x in range(2):
            use = data[data_point]
            # If x = 0 then it is the first section and you need to have the operator as + to go right across the data
            if x == 0:
                op = operator.add
                length = 0
            else:
                op = operator.sub
                length = len(use) - 1
            point = GraphAnalysis.go_along_data(use, length, op)
            toadd.append(point)
        final_sections.append(toadd[:])
        toadd.clear()
    returnsections = []
    passback = []

    # Work out the peaks
    for section in range(len(final_sections)):
        firstpeak = data[section][0:final_sections[section][0]]
        middlepeak = data[section][final_sections[section][0]:final_sections[section][1]]
        lastpeak = data[section][final_sections[section][1]: len(data[section])]
        returnsections.append(firstpeak)
        returnsections.append(middlepeak)
        returnsections.append(lastpeak)
        passback.append(returnsections[:])
        returnsections.clear()
    return final_sections, passback


# This is called from get_intensity and takes the data generated by it and will make simple graphs from the data
# the Y axis is the intensity and the X axis is the pixel number (basically depth)
def simple_graphing(data, centroidedges, filename):
    for current_data_position in range(len(data)):

        data_point = data[current_data_position]
        title = ("Lane " + str(current_data_position))
        count = []
        for x in range(len(data_point)):
            count.append(x)

        fig, ax = plt.subplots()
        ax.plot(count, data_point)
        fig.suptitle(title)

        plt.axvline(x=0)
        plt.axvline(x=centroidedges[current_data_position][0])
        plt.axvline(x=centroidedges[current_data_position][1])
        plt.axvline(x=len(data[current_data_position]) - 1)
        final_location = filename + "_lane_" + str(current_data_position) + ".png"
        plt.savefig(final_location)
        plt.close(fig)


# Handles the filesaving
def caller_function(datas, filepath):
    import FileWriter
    areas = get_areas(datas)
    maxes = get_maxes(datas)
    FileWriter.write_to_file(areas, maxes, filepath)


# Calculate the area underneath the graph given the data.
def get_areas(datas):
    areas = []
    for data in datas:
        toadd = []
        for i in data:
            y = np.array(i)
            area = trapz(y, dx=1)
            toadd.append(area)
        areas.append(toadd[:])
        toadd.clear()

    return normalise_values(areas)


def normalise_values(data):
    normalised_values = []
    for values in data:
        toadd = []
        total = sum(values)
        toadd.append(round((values[0] / total) * 100, 2))
        toadd.append(round((values[1] / total) * 100, 2))
        toadd.append(round((values[2] / total) * 100, 2))
        normalised_values.append(toadd[:])
        toadd.clear()

    return normalised_values
    # FileWriter.write_to_file(normalised_values)


# Run along the data and find the max for each section
def get_maxes(datas):
    maxes = []
    for data in datas:
        toadd = []
        for section in data:
            toadd.append(max(section))
        maxes.append(toadd[:])
        toadd.clear()
    return normalise_values(maxes)
