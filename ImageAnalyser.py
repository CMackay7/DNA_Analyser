# This file is used for all the analysis of the image
import matplotlib.pyplot as plt
import numpy as np
from numpy import trapz
from scipy.signal import argrelextrema
import ImageManipulation
import cv2
from tkinter import *

PIXEL_HEIGHT = 8  # radius i.e. middle to top DEFAULT = 8
CUT_OFF = 2000  # This value is used to find the end of dna spots, if the brightness is under 2000 it assumes it is
# the end of a dna spot
root = Tk()


# Get intensity is passed the image and the lines. It will run along the pixels in each line and get the intensity
# of each pixel adds all the intensities to a list
def get_intensity(image, centroids):
    centroids = extend_points(centroids, image)
    ImageManipulation.draw_lanes(centroids, image.copy())
    cv2.imshow('testimage', ImageManipulation.draw_lanes(centroids, image.copy()))
    cv2.waitKey(0)
    single_row_intensities = []
    all_intensities = []
    _, width, _ = image.shape

    for point in centroids:
        lengthofcent = len(point)
        start = point[0][0]
        end = point[lengthofcent - 1][0]
        y = point[0][1]
        # todo: fix this
        for i in range(start, end):
            addintensity = 0
            for yedit in range(-PIXEL_HEIGHT, PIXEL_HEIGHT):
                # The intensity of the image is calculated by taking the values for red blue and green and summing the
                # values.
                r, b, g = image[y, i]
                r = int(r)
                b = int(b)
                g = int(g)
                # Convert to int so it doesn't get an error
                intensity = int(r + b + g)
                addintensity = addintensity + intensity
            single_row_intensities.append(addintensity)

        all_intensities.append(single_row_intensities[:])
        single_row_intensities.clear()
    # some_testing(all_intensities, centroids, image)
    tosend = decrease_values(all_intensities)
    some_testing(tosend, centroids, image)


# This is called from get_intensity and takes the data generated by it and will make simple graphs from the data
# the Y axis is the intensity and the X axis is the pixel number (basically depth)
def simple_graphing(data, centroidedges):
    for i in range(len(data)):

        data_point = data[i]
        title = ("Lane " + str(i))
        count = []
        for x in range(len(data_point)):
            count.append(x)

        fig, ax = plt.subplots()
        ax.plot(count, data_point)
        fig.suptitle(title)

        plt.axvline(x=centroidedges[i][0][0] - centroidedges[i][0][0])
        plt.axvline(x=centroidedges[i][1][0] - centroidedges[i][0][0])
        plt.axvline(x=centroidedges[i][2][0] - centroidedges[i][0][0])
        plt.axvline(x=len(data[i]) - 1)
        # plt.show()
        # Uncomment this so show graphs


# Sorts centroids
def sort_cent(cent):
    sorted_centroids = sorted(cent, key=lambda x: x[0])
    return sorted_centroids


# This function makes sure that the whole light spot (left and right) will get analysed
# it will extend the length of the line until there is no more light and therefore not the dna
def extend_points(centroids, image):
    to_add = []
    to_be_added_to = []
    _, width, _ = image.shape

    # Loop through the lines, extend the first point on each line until it is no longer on the dna, do the same
    # with the last point on the line
    for cent in centroids:
        cent = sort_cent(cent)
        cent_len = len(cent)
        for i in range(cent_len):
            x = cent[i][0]
            y = cent[i][1]
            # If first point go here
            if i == 0:
                end_hit = False
                changer = 1
                while not end_hit:
                    totalint = 0
                    for changey in range(-8, 8):
                        r, b, g = image[y + changey, x - changer]
                        intent = pixel_intent(r, g, b)
                        totalint = totalint + intent
                    if totalint < CUT_OFF or x - changer == 0:
                        end_hit = True
                    else:
                        changer = changer + 1
                edited_point = (x - changer, cent[0][1])
                # If it is the final point go here
            elif i == cent_len - 1:
                end_hit = False
                changer = 1
                while not end_hit:
                    totalint = 0
                    for changey in range(-8, 8):
                        r, b, g = image[y + changey, x + changer]
                        intent = pixel_intent(r, g, b)
                        totalint = totalint + intent
                    if totalint < CUT_OFF or cent[i][0] + changer == width - 1:
                        end_hit = True
                    else:
                        changer = changer + 1
                edited_point = (cent[i][0] + changer, cent[i][1])
                # If it is neither it means the point is in the middle of the line, therefore it doesnt need changing
                # so just copy it over
            else:
                edited_point = cent[i]
            to_add.append(edited_point)
        to_be_added_to.append(to_add[:])
        to_add.clear()
    return to_be_added_to


# Given red, blue and green values for a pixel it converts it to integers and sums them, it doesnt do
# a lot of computation but it gets called a lot so it saves space
def pixel_intent(r, g, b):
    r = int(r)
    b = int(b)
    g = int(g)
    # Convert to int so it doesn't get an error
    intensity = int(r + b + g)
    return intensity


# This method is used to fund the edges of the dna spots. It returns the end of the fist spot and
# the start of the final dna spot will be changed to make it better soon
def find_edges(centroids, image):
    to_add = []
    to_be_added_to = []
    _, width, _ = image.shape
    edgy_centroids = []

    for cent in centroids:
        lenny = len(cent)
        for i in range(lenny):
            x = cent[i][0]
            y = cent[i][1]
            cent_len = lenny
            if i == 0:
                end_hit = False
                changer = 1
                while not end_hit:
                    totalint = 0
                    for changey in range(-8, 8):
                        r, b, g = image[y + changey, x + changer]
                        intent = pixel_intent(r, g, b)
                        totalint = totalint + intent
                    if totalint < CUT_OFF or cent[i][0] + changer == width:
                        end_hit = True
                    else:
                        changer = changer + 1
                edited_point = (x + changer, cent[0][1])
                to_add.append(cent[i])
                to_add.append(edited_point)

            elif i == cent_len - 1:
                end_hit = False
                changer = 1
                while not end_hit:
                    totalint = 0
                    for changey in range(-8, 8):
                        r, b, g = image[y + changey, x - changer]
                        intent = pixel_intent(r, g, b)
                        totalint = totalint + intent
                    if totalint < CUT_OFF or cent[i][0] - changer <= 0:
                        end_hit = True
                    else:
                        changer = changer + 1
                edited_point = (x - changer, cent[0][1])
                to_add.append(edited_point)
                to_add.append(cent[i])

        edgy_centroids.append(to_add[:])
        to_add.clear()
    return edgy_centroids


# Just use to decrease values that are in background to 0 so middle values doesn't get free area
# for now it will just -1500 (generally what I've seen as the cut off between on cells and not)
# hopefully this will be changed later
def decrease_values(data):
    newvals = []
    toreturn = []
    for intensityrow in data:
        for x in intensityrow:
            if x - 1500 <= 0:
                newvals.append(0)
            else:
                newvals.append(x - 1500)
        toreturn.append(newvals[:])
        newvals.clear()
    return toreturn


# Will be eventually used to calculate the areas under each peak they will be normalised to get the % of
# dna in each bit
def get_areas_under(data):
    print()


def split_into_sections(data, sections):
    returnsections = []
    passback = []
    for i in range(len(sections)):
        start1 = sections[i][0][0] - sections[i][0][0]
        end1 = sections[i][1][0] - sections[i][0][0]
        start2 = sections[i][2][0] - sections[i][0][0]
        end2 = sections[i][3][0] - sections[i][0][0]
        end3 = data[i][len(data) - 1]
        firstpeak = data[i][start1:end1]
        middle = data[i][end1:start2]
        lastpeak = data[i][start2:len(data[i])]

        returnsections.append(firstpeak)
        returnsections.append(middle)
        returnsections.append(lastpeak)

        passback.append(returnsections[:])
        returnsections.clear()

    return passback


# This is just to test some stuff to do with editing the data remove at the end
def some_testing(data, centroids, image):
    a = np.array(data[0])
    print("1")
    maxInd = argrelextrema(a, np.greater)
    print(maxInd)
    print("2")
    r = a[maxInd]
    centroids_with_edges = find_edges(centroids, image)
    check = split_into_sections(data, centroids_with_edges)
    simple_graphing(data, centroids_with_edges)
    get_areas(check)
    print("3")
    print(r)


def get_areas(datas):
    areas = []
    for data in datas:
        toadd = []
        for i in data:
            y = np.array(i)
            area = trapz(y, dx=1)
            toadd.append(area)
        areas.append(toadd[:])
        toadd.clear()

    normalise_values(areas)


def normalise_values(data):
    import FileWriter
    normalised_values = []
    for values in data:
        toadd = []
        total = sum(values)
        toadd.append(round((values[0] / total)*100, 2))
        toadd.append(round((values[1] / total)*100, 2))
        toadd.append(round((values[2] / total)*100, 2))
        normalised_values.append(toadd[:])
        toadd.clear()

    FileWriter.write_to_file(normalised_values)

